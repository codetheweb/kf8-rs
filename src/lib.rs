use nom::{
    branch::alt,
    bytes::complete::{tag, take, take_while},
    character::complete::{alphanumeric1, char},
    combinator::map,
    error::ErrorKind,
    number::complete::{be_u16, be_u32},
    sequence::tuple,
    IResult,
};
use std::str::{self, FromStr};

use crate::constants::{MainLanguage, SubLanguage};

#[macro_use]
extern crate lazy_static;

mod constants;

#[derive(Debug, PartialEq)]
pub struct SectionHeader {
    offset: u32,
    flags: u8,
    val: u32,
}

#[derive(Debug, PartialEq)]
enum MobiHeaderIdent {
    BookMobi,
    TextRead,
}

#[derive(Debug, PartialEq)]
pub struct MobiHeader {
    name: String,
    num_sections: u16,
    ident: MobiHeaderIdent,
    section_headers: Vec<SectionHeader>,
}

fn parse_name(input: &[u8]) -> IResult<&[u8], String> {
    let (input, name_bytes) = take(32usize)(input)?;

    let name = map(take_while(|b| b != 0x00), |bytes| {
        str::from_utf8(bytes).unwrap_or_default().to_string()
    })(name_bytes)?;

    Ok((input, name.1))
}

fn parse_ident(input: &[u8]) -> IResult<&[u8], MobiHeaderIdent> {
    alt((tag("BOOKMOBI"), tag("TEXTREAD")))(input).map(|(input, ident)| {
        let ident = match ident {
            b"BOOKMOBI" => MobiHeaderIdent::BookMobi,
            b"TEXTREAD" => MobiHeaderIdent::TextRead,
            _ => unreachable!(),
        };
        (input, ident)
    })
}

fn parse_section_header(input: &[u8]) -> IResult<&[u8], SectionHeader> {
    let (input, (offset, flags_vals)) = tuple((be_u32, take(4usize)))(input)?;
    let flags = flags_vals[0];
    let val = (flags_vals[1] as u32) << 16 | (flags_vals[2] as u32) << 8 | flags_vals[3] as u32;
    Ok((input, SectionHeader { offset, flags, val }))
}

fn parse_mobi_header(input: &[u8]) -> IResult<&[u8], MobiHeader> {
    let (input, header) = take(72usize)(input)?;
    let (input, _) = take(4usize)(input)?;
    let (input, num_sections) = be_u16(input)?;

    if num_sections == 0 {
        todo!("should return error")
    }

    let (input, _) = take(2usize)(input)?;

    let (_, name) = parse_name(header)?;
    let (_, ident) = parse_ident(&header[0x3C..])?;

    let (mut input, mut section_headers) = (input, Vec::new());
    for _ in 0..num_sections {
        let (i, section_header) = parse_section_header(input)?;
        section_headers.push(section_header);
        input = i;
    }

    Ok((
        input,
        MobiHeader {
            name,
            num_sections,
            ident,
            section_headers,
        },
    ))
}

#[derive(Debug, PartialEq)]
pub struct Section {}

fn parse_section(input: &[u8]) -> IResult<&[u8], Section> {
    todo!()
}

// Some KF8 files have header length == 264 (generated by kindlegen 2.9?). See https://bugs.launchpad.net/bugs/1179144
// We choose 500 for future versions of kindlegen
const MAX_HEADER_LENGTH: usize = 500;

const NULL_INDEX: u32 = u32::MAX;

fn parse_book_header<'a>(input: &'a [u8], mobi_header: &MobiHeader) -> IResult<&'a [u8], ()> {
    let total_remaining_input_length = input.len();

    let (input, compression_type) = be_u16(input)?;
    let (input, _) = take(6usize)(input)?; // Skip 6 bytes
    let (input, records) = be_u16(input)?;
    let (input, records_size) = be_u16(input)?;
    let (input, encryption_type) = be_u16(input)?;

    println!("Compression Type: {:?}", compression_type);
    println!("Records: {:?}", records);
    println!("Records Size: {:?}", records_size);
    println!("Encryption Type: {:?}", encryption_type);

    let (input, _) = take(2usize)(input)?; // Skip 2 bytes
    let (input, doctype) = take(4usize)(input)?;

    // 20 bytes past input

    println!(
        "Doc Type: {:?}",
        str::from_utf8(doctype).unwrap_or_default()
    );
    // todo: assert on doc type?

    // todo: handle cp1252?

    let (input, length) = be_u32(input)?;
    let (input, type_field) = be_u32(input)?;
    let (input, codepage) = be_u32(input)?;
    let (input, unique_id) = be_u32(input)?;
    let (input, version) = be_u32(input)?;

    // 40 bytes past input

    println!("Length: {:?}", length);
    println!("Type: {:?}", type_field);
    println!("Codepage: {:?}", codepage);
    println!("Unique ID: {:?}", unique_id);
    println!("Version: {:?}", version);

    if codepage == 1252 {
        // todo: return error/handle cp1252
        panic!("cp1252 not supported")
    }

    let (input, _) = take(52usize)(input)?; // Skip 52 bytes

    let (input, langcode) = be_u32(input)?;
    println!("Langcode: {:?}", langcode);

    let langid = langcode & 0xff;
    let sublangid = (langcode >> 10) & 0xff;

    // todo: don't unwrap
    let language = MainLanguage::try_from(langid).unwrap();
    let sublanguage = SubLanguage::try_from(sublangid).unwrap();

    println!("Language: {:?}", language);
    println!("Sublanguage: {:?}", sublanguage);

    let (input, _) = take(8usize)(input)?; // Skip 8 bytes

    let (input, mobi_version) = be_u32(input)?;

    println!("Mobi Version: {:?}", mobi_version);

    let (input, first_image_index) = be_u32(input)?;

    println!("First Image Index: {:?}", first_image_index);

    let (input, _) = take(16usize)(input)?; // Skip 12 bytes

    let (input, exth_flag) = be_u32(input)?;
    // todo: exth parsing (extended header, mostly DRM?)
    println!("EXTH Flag: {:?}", exth_flag);

    // at 132 bytes past input

    let should_read_extra_flag = mobi_header.ident == MobiHeaderIdent::TextRead
        || length < 0xe4
        || length > MAX_HEADER_LENGTH as u32;
    let mut extra_flags = 0;

    let (input, skelidx, dividx, othidx, fdstidx, datpidx, fdstcnt) =
        if mobi_version == 8 && total_remaining_input_length >= (0xf8 + 16) {
            let (input, _) = take(60usize)(input)?; // Skip 60 bytes

            let (input, (mut fdstidx, fdstcnt)) = tuple((be_u32, be_u32))(input)?;
            let (input, _) = take(42usize)(input)?; // Skip 42 bytes

            let input = if should_read_extra_flag {
                let (input, flags) = be_u16(input)?;
                extra_flags = flags;

                // Skip 4 bytes
                take(4usize)(input)?.0
            } else {
                take(6usize)(input)?.0
            };

            println!(
                "consumed bytes: {}",
                total_remaining_input_length - input.len()
            );

            let (input, (dividx, skelidx, datpidx, othidx)) =
                tuple((be_u32, be_u32, be_u32, be_u32))(input)?;

            if fdstcnt <= 1 {
                fdstidx = NULL_INDEX;
            }

            (input, skelidx, dividx, othidx, fdstidx, datpidx, fdstcnt)
        } else {
            // todo: read extra flag

            (
                input, NULL_INDEX, NULL_INDEX, NULL_INDEX, NULL_INDEX, NULL_INDEX, NULL_INDEX,
            )
        };

    println!("skelidx: {:?}", skelidx);
    println!("dividx: {:?}", dividx);
    println!("othidx: {:?}", othidx);
    println!("fdstidx: {:?}", fdstidx);
    println!("datpidx: {:?}", datpidx);
    println!("fdstcnt: {:?}", fdstcnt);

    println!("Extra Flags: {:?}", extra_flags);

    Ok((input, ()))
}

#[derive(Debug, PartialEq)]
pub struct MobiBook {
    mobi_header: MobiHeader,
}

fn parse_book(input: &[u8]) -> IResult<&[u8], MobiBook> {
    let (input, mobi_header) = parse_mobi_header(input)?;

    parse_book_header(input, &mobi_header)?;

    // let (input, book_header) = parse_section(input)?;

    // println!("Book Header: {:?}", book_header);

    Ok((input, MobiBook { mobi_header }))
}

#[cfg(test)]
mod tests {
    use std::io::Read;

    use super::*;

    #[test]
    fn it_works() {
        // reader for resources/war_and_peace.azw3
        let mut reader = std::fs::File::open("resources/war_and_peace.azw3").unwrap();
        let mut data = Vec::new();
        reader.read_to_end(&mut data).unwrap();

        match parse_book(&data[0..4096 * 2 * 2]) {
            Ok((remaining, result)) => {
                // println!("Extracted String: {:?}", result);
                // println!("Remaining bytes: {:?}", remaining);
            }
            Err(e) => println!("Failed to parse: {:?}", e),
        }
    }
}
