use nom::{
    branch::alt,
    bytes::complete::{tag, take, take_while},
    combinator::map,
    multi::count,
    number::complete::{be_u16, be_u24, be_u32, be_u8},
    sequence::tuple,
    IResult,
};
use std::{
    collections::HashMap,
    iter::once,
    str::{self, FromStr},
};

use crate::{
    constants::{MainLanguage, SubLanguage},
    tag_map::{parse_tag_map, parse_tag_section},
};

#[macro_use]
extern crate lazy_static;

mod constants;
mod tag_map;

#[derive(Debug, PartialEq)]
pub struct SectionHeader {
    offset: u32,
    flags: u8,
    val: u32,
}

#[derive(Debug, PartialEq)]
enum MobiHeaderIdent {
    BookMobi,
    TextRead,
}

#[derive(Debug, PartialEq)]
enum CompressionType {
    None,
    PalmDoc,
    HuffCdic,
}

fn parse_compression_type(input: &[u8]) -> IResult<&[u8], CompressionType> {
    alt((
        map(tag([0x00, 0x01]), |_| CompressionType::None),
        map(tag([0x00, 0x02]), |_| CompressionType::PalmDoc),
        map(tag([0x44, 0x48]), |_| CompressionType::HuffCdic),
    ))(input)
}

#[derive(Debug, PartialEq)]
pub struct MobiHeader {
    name: String,
    num_sections: u16,
    ident: MobiHeaderIdent,
    section_headers: Vec<SectionHeader>,
}

fn parse_name(input: &[u8]) -> IResult<&[u8], String> {
    let (input, name_bytes) = take(32usize)(input)?;

    let name = map(take_while(|b| b != 0x00), |bytes| {
        // todo: should conditionally be utf8 or cp1252 based on codec in header
        str::from_utf8(bytes).unwrap_or_default().to_string()
    })(name_bytes)?;

    Ok((input, name.1))
}

fn parse_ident(input: &[u8]) -> IResult<&[u8], MobiHeaderIdent> {
    alt((tag("BOOKMOBI"), tag("TEXTREAD")))(input).map(|(input, ident)| {
        let ident = match ident {
            b"BOOKMOBI" => MobiHeaderIdent::BookMobi,
            b"TEXTREAD" => MobiHeaderIdent::TextRead,
            _ => unreachable!(),
        };
        (input, ident)
    })
}

fn parse_section_header(input: &[u8]) -> IResult<&[u8], SectionHeader> {
    let (input, (offset, flags, val)) = tuple((be_u32, be_u8, be_u24))(input)?;
    Ok((input, SectionHeader { offset, flags, val }))
}

fn parse_mobi_header(input: &[u8]) -> IResult<&[u8], MobiHeader> {
    let (input, header) = take(72usize)(input)?;
    let (input, _) = take(4usize)(input)?;
    let (input, num_sections) = be_u16(input)?;

    if num_sections == 0 {
        todo!("should return error")
    }

    let (_, name) = parse_name(header)?;
    let (_, ident) = parse_ident(&header[0x3C..])?;

    let (mut input, mut section_headers) = (input, Vec::new());
    for _ in 0..num_sections {
        let (i, section_header) = parse_section_header(input)?;
        section_headers.push(section_header);
        input = i;
    }

    Ok((
        input,
        MobiHeader {
            name,
            num_sections,
            ident,
            section_headers,
        },
    ))
}

#[derive(Debug, PartialEq)]
enum Codepage {
    Cp1252,
    Utf8,
}

fn parse_codepage(input: &[u8]) -> IResult<&[u8], Codepage> {
    alt((
        map(tag([0x00, 0x00, 0x04, 0xe4]), |_| Codepage::Cp1252),
        map(tag([0x00, 0x00, 0xfd, 0xe9]), |_| Codepage::Utf8),
    ))(input)
}

// Some KF8 files have header length == 264 (generated by kindlegen 2.9?). See https://bugs.launchpad.net/bugs/1179144
// We choose 500 for future versions of kindlegen
const MAX_HEADER_LENGTH: usize = 500;

const NULL_INDEX: u32 = u32::MAX;

#[derive(Debug, PartialEq, Clone)]
struct K8Header {
    skelidx: u32,
    fragidx: u32,
    guideidx: u32,
    fdst: u32,
    fdst_count: u32,
}

#[derive(Debug, PartialEq)]
struct BookHeader {
    compression_type: CompressionType,
    records: u16,
    records_size: u16,
    // todo: enum?
    encryption_type: u16,
    // todo: enum?
    doctype: String,
    ncxidx: u32,
    // todo: enum/split up/rename
    extra_flags: Option<u16>,
    k8: Option<K8Header>,
}

impl BookHeader {
    fn sizeof_trailing_section_entries(&self, section_data: &[u8]) -> usize {
        let mut num = 0;
        let size = section_data.len();
        let mut flags = self.extra_flags.unwrap() >> 1;

        fn sizeof_trailing_section_entry(section_data: &[u8], offset: usize) -> usize {
            let mut offset = offset;
            let mut bitpos = 0;
            let mut result: usize = 0;

            loop {
                let v = section_data[offset - 1] as usize;
                result |= (v & 0x7f) << bitpos;
                bitpos += 7;
                offset -= 1;

                if (v & 0x80) != 0 || (bitpos >= 28) || offset == 0 {
                    return result;
                }
            }
        }

        while flags > 0 {
            if flags & 1 > 0 {
                num += sizeof_trailing_section_entry(section_data, size - num);
            }

            flags >>= 1;
        }

        if self.extra_flags.unwrap() & 1 > 0 {
            let offset = size - num - 1;
            num += (section_data[offset] as usize & 0x3) + 1;
        }

        num
    }
}

fn parse_book_header<'a>(
    data: &'a [u8],
    mobi_header: &MobiHeader,
) -> IResult<&'a [u8], BookHeader> {
    let total_remaining_input_length = data.len();

    let (input, compression_type) = parse_compression_type(data)?;
    let (input, _) = take(6usize)(input)?; // Skip 6 bytes
    let (input, records) = be_u16(input)?;
    let (input, records_size) = be_u16(input)?;
    let (input, encryption_type) = be_u16(input)?;

    println!("Compression Type: {:?}", compression_type);
    println!("Records: {:?}", records);
    println!("Records Size: {:?}", records_size);
    println!("Encryption Type: {:?}", encryption_type);

    let (input, _) = take(2usize)(input)?; // Skip 2 bytes
    let (input, doctype) = take(4usize)(input)?;

    // 20 bytes past input

    println!(
        "Doc Type: {:?}",
        str::from_utf8(doctype).unwrap_or_default()
    );
    // todo: assert on doc type?

    // todo: handle cp1252?

    let (input, length) = be_u32(input)?;
    let (input, type_field) = be_u32(input)?;
    let (input, codepage) = parse_codepage(input)?;
    let (input, unique_id) = be_u32(input)?;
    let (input, version) = be_u32(input)?;

    // 40 bytes past input

    println!("Length: {:?}", length);
    println!("Type: {:?}", type_field);
    println!("Codepage: {:?}", codepage);
    println!("Unique ID: {:?}", unique_id);
    println!("Version: {:?}", version);

    if codepage == Codepage::Cp1252 {
        // todo: return error/handle cp1252
        panic!("cp1252 not supported")
    }

    let (input, _) = take(52usize)(input)?; // Skip 52 bytes

    let (input, langcode) = be_u32(input)?;
    println!("Langcode: {:?}", langcode);

    let langid = langcode & 0xff;
    let sublangid = (langcode >> 10) & 0xff;

    // todo: don't unwrap
    let language = MainLanguage::try_from(langid).unwrap();
    let sublanguage = SubLanguage::try_from(sublangid).unwrap();

    println!("Language: {:?}", language);
    println!("Sublanguage: {:?}", sublanguage);

    let (input, _) = take(8usize)(input)?; // Skip 8 bytes

    let (input, mobi_version) = be_u32(input)?;

    println!("Mobi Version: {:?}", mobi_version);

    let (input, first_image_index) = be_u32(input)?;

    println!("First Image Index: {:?}", first_image_index);

    let (input, _) = take(16usize)(input)?; // Skip 12 bytes

    let (input, exth_flag) = be_u32(input)?;
    // todo: exth parsing (extended header, mostly DRM?)

    // at 132 bytes past input

    let (_, ncxidx) = be_u32(&data[0xf4..])?;

    let mut header = BookHeader {
        compression_type,
        records,
        records_size,
        doctype: String::from_utf8(doctype.to_vec()).unwrap(),
        encryption_type,
        ncxidx,
        k8: None,
        extra_flags: None,
    };

    if mobi_version >= 5 && length >= 0xe4 {
        let (_, flags) = be_u16(&data[0xf2..])?;
        header.extra_flags = Some(flags);
    }

    if mobi_version == 8 {
        let (_, skelidx) = be_u32(&data[0xfc..])?;
        let (_, fragidx) = be_u32(&data[0xf8..])?;
        let (_, guideidx) = be_u32(&data[0x104..])?;
        let (_, fdst) = be_u32(&data[0xc0..])?;
        let (_, fdst_count) = be_u32(&data[0xc4..])?;

        header.k8 = Some(K8Header {
            skelidx,
            fragidx,
            guideidx,
            fdst,
            fdst_count,
        })
    }

    Ok((input, header))
}

#[derive(Debug, PartialEq)]
pub struct MobiBook {
    mobi_header: MobiHeader,
    content: String,
}

fn get_section_data<'a>(data: &'a [u8], mobi_header: &MobiHeader, section_i: usize) -> &'a [u8] {
    let end_offset = if section_i == (mobi_header.num_sections - 1).into() {
        data.len()
    } else {
        mobi_header.section_headers[section_i + 1].offset as usize
    };

    let section_header = &mobi_header.section_headers[section_i];

    &data[section_header.offset as usize..end_offset]
}

fn parse_book(input: &[u8]) -> IResult<&[u8], MobiBook> {
    let original_input = input;
    let original_input_length = input.len();
    let (input, mobi_header) = parse_mobi_header(input)?;

    let (input, _) = take(2usize)(input)?; // Skip 2 bytes

    // todo: use first section offset instead of manually skipping bytes above?
    let (_, book_header) = parse_book_header(
        &original_input[mobi_header.section_headers.first().unwrap().offset as usize..],
        &mobi_header,
    )?;

    if book_header.k8.is_none() {
        panic!("book does not have a k8 header, either malformed or unsupported")
    }

    let mut raw_ml = Vec::new();
    for (i, section_header) in mobi_header.section_headers.iter().enumerate().skip(1) {
        if i > book_header.records as usize {
            break;
        }

        let section_data = get_section_data(original_input, &mobi_header, i);
        let section_data = &section_data
            [..section_data.len() - book_header.sizeof_trailing_section_entries(section_data)];

        let decompressed = palmdoc_compression::calibre::decompress(section_data);

        raw_ml.extend_from_slice(&decompressed);
    }

    // Parse flow boundaries
    let fdst_section_data = get_section_data(
        original_input,
        &mobi_header,
        book_header.k8.clone().unwrap().fdst as usize,
    );

    let (_, fdst_table) = parse_fdst(fdst_section_data, raw_ml.len()).unwrap();

    let mut flows = Vec::new();

    for (starts_at, ends_at) in fdst_table.iter().zip(fdst_table.iter().skip(1)) {
        let flow = &raw_ml[*starts_at..*ends_at];
        flows.push(flow);
    }

    let text = *flows.first().unwrap();

    let (_, skeleton_table) = parse_index_data(
        original_input,
        &mobi_header,
        book_header.k8.clone().unwrap().skelidx as usize,
    )?;

    println!(
        "fragment index: {}",
        book_header.k8.clone().unwrap().fragidx
    );

    let (_, fragment_table) = parse_index_data(
        original_input,
        &mobi_header,
        book_header.k8.unwrap().fragidx as usize,
    )?;

    let fragment_table = index_table_to_fragment_table(&fragment_table);

    let mut fragment_i = 0;
    for skeleton_entry in index_table_to_skeleton_table(&skeleton_table) {
        let mut base_ptr = skeleton_entry.start_offset + skeleton_entry.len;

        println!(
            "num records: {}",
            skeleton_entry.fragment_table_record_count
        );

        let mut assembled_text = text
            [skeleton_entry.start_offset..skeleton_entry.start_offset + skeleton_entry.len]
            .to_vec();

        // todo: zip?
        for _ in 0..skeleton_entry.fragment_table_record_count {
            let fragment_entry = fragment_table.get(fragment_i).unwrap();

            let fragment_text = &text[base_ptr..base_ptr + fragment_entry.len as usize];
            println!(
                "insert position: {}, parent skeleton offset: {}, fragment len: {}, assembled text len: {}",
                fragment_entry.insert_position, skeleton_entry.start_offset, fragment_entry.len, assembled_text.len()
            );
            let fragment_insert_position =
                (fragment_entry.insert_position as usize) - skeleton_entry.start_offset;

            assembled_text = [
                &assembled_text[..fragment_insert_position],
                fragment_text,
                &assembled_text[fragment_insert_position..],
            ]
            .concat();

            base_ptr += fragment_entry.len as usize;
            fragment_i += 1;
        }

        println!("assembled: {}", String::from_utf8(assembled_text).unwrap());
        println!("----------------------------------------------------------------------------------------")
    }

    Ok((
        input,
        MobiBook {
            mobi_header,
            // todo: this should not be lossy
            content: String::from_utf8_lossy(&raw_ml).to_string(),
        },
    ))
}

#[derive(Debug)]
struct IndexTableEntry {
    file_number: usize,
    label: String,
    tag_map: HashMap<u8, Vec<u32>>,
}

fn parse_index_data<'a>(
    original_input: &'a [u8],
    mobi_header: &MobiHeader,
    section_i: usize,
) -> IResult<&'a [u8], Vec<IndexTableEntry>> {
    // Parse INDX header
    let indx_section_data = get_section_data(original_input, mobi_header, section_i);
    let (_, indx_header) = parse_indx_header(indx_section_data).unwrap();
    println!("INDX Header: {:?}", indx_header);

    let (_, tag_section) =
        parse_tag_section(&indx_section_data[indx_header.len as usize..]).unwrap();

    let mut skeleton_table = vec![];

    for i in (section_i + 1)..(section_i + 1 + indx_header.count as usize) {
        let data = get_section_data(original_input, mobi_header, i);
        let (_, header) = parse_indx_header(data).unwrap();

        let (_, indx_offsets) =
            count(be_u16, header.count as usize)(&data[header.start as usize + 4..])?;

        for (i, beginning_offset) in indx_offsets.iter().enumerate() {
            let (remaining, segment) =
                parse_indx_text_segment(&data[*beginning_offset as usize..])?;

            let (_, tag_map) = parse_tag_map(
                tag_section.control_byte_count,
                &tag_section.table,
                remaining,
            )
            .unwrap();

            skeleton_table.push(IndexTableEntry {
                file_number: i,
                label: segment,
                tag_map,
            });
        }
    }

    Ok((&[], skeleton_table))
}

#[derive(Debug)]
struct SkeletonTableEntry {
    file_number: usize,
    label: String,
    fragment_table_record_count: usize,
    start_offset: usize,
    len: usize,
}

fn index_table_to_skeleton_table(table_entries: &[IndexTableEntry]) -> Vec<SkeletonTableEntry> {
    table_entries
        .iter()
        .map(|entry| SkeletonTableEntry {
            file_number: entry.file_number,
            label: entry.label.clone(),
            fragment_table_record_count: entry.tag_map.get(&1).unwrap()[0] as usize,
            start_offset: entry.tag_map.get(&6).unwrap()[0] as usize,
            len: entry.tag_map.get(&6).unwrap()[1] as usize,
        })
        .collect()
}

#[derive(Debug)]
struct FragmentTableEntry {
    insert_position: u32,
    id_text: String,
    file_number: u32,
    seq_number: u32,
    start_pos: u32,
    len: u32,
}

fn index_table_to_fragment_table(table_entries: &[IndexTableEntry]) -> Vec<FragmentTableEntry> {
    println!("fragment table: {:?}", table_entries);
    table_entries
        .iter()
        .map(|entry| FragmentTableEntry {
            insert_position: u32::from_str(&entry.label).unwrap(),
            // todo
            id_text: "".to_string(),
            file_number: entry.tag_map.get(&3).unwrap()[0],
            seq_number: entry.tag_map.get(&4).unwrap()[0],
            start_pos: entry.tag_map.get(&6).unwrap()[0],
            len: entry.tag_map.get(&6).unwrap()[1],
        })
        .collect()
}

fn parse_indx_text_segment(input: &[u8]) -> IResult<&[u8], String> {
    let (input, len) = be_u8(input)?;
    let (input, segment) = take(len as usize)(input)?;

    // todo: remove unwrap
    Ok((input, String::from_utf8(segment.to_vec()).unwrap()))
}

fn parse_fdst(input: &[u8], raw_ml_len: usize) -> IResult<&[u8], Vec<usize>> {
    let (input, _) = tag(b"FDST")(input)?;
    let (input, _) = take(4usize)(input)?;
    let (input, num_sections) = be_u32(input)?;
    let (input, sections) = count(be_u32, num_sections as usize * 2)(input)?;

    let positions = sections
        .iter()
        .step_by(2)
        .map(|x| *x as usize)
        .chain(once(raw_ml_len))
        .collect();

    Ok((input, positions))
}

#[derive(Debug)]
struct INDXHeader {
    len: u32,
    nul1: u32,
    type_field: u32,
    gen: u32,
    start: u32,
    count: u32,
    code: u32,
    lng: u32,
    total: u32,
    ordt: u32,
    ligt: u32,
    nligt: u32,
    nctoc: u32,
    ordt1: Option<Vec<u8>>,
    ordt2: Option<Vec<u16>>,
}

fn parse_indx_header(input: &[u8]) -> IResult<&[u8], INDXHeader> {
    let (input, _) = tag(b"INDX")(input)?;

    let (
        input,
        (len, nul1, type_field, gen, start, count, code, lng, total, ordt, ligt, nligt, nctoc),
    ) = tuple((
        be_u32, be_u32, be_u32, be_u32, be_u32, be_u32, be_u32, be_u32, be_u32, be_u32, be_u32,
        be_u32, be_u32,
    ))(input)?;

    let (input, (ocnt, oentries, op1, op2, _otagx)) =
        tuple((be_u32, be_u32, be_u32, be_u32, be_u32))(input)?;

    let ordt1;
    let ordt2;

    if code == 0xfdea || ocnt != 0 || oentries > 0 {
        ordt1 = Some(take(oentries as usize)(input)?.1.to_vec());
        ordt2 = Some(nom::multi::count(be_u16, oentries as usize)(input)?.1);
    } else {
        ordt1 = None;
        ordt2 = None;
    }

    Ok((
        input,
        INDXHeader {
            len,
            nul1,
            type_field,
            gen,
            start,
            count,
            code,
            lng,
            total,
            ordt,
            ligt,
            nligt,
            nctoc,
            ordt1,
            ordt2,
        },
    ))
}

#[cfg(test)]
mod tests {
    use std::io::{Read, Write};

    use super::*;

    #[test]
    fn extract_raw_html() {
        let mut reader = std::fs::File::open("resources/war_and_peace.azw3").unwrap();
        let mut data = Vec::new();
        reader.read_to_end(&mut data).unwrap();

        let (_, book) = parse_book(&data).unwrap();

        let mut expected_html_reader =
            std::fs::File::open("resources/war_and_peace.rawml").unwrap();
        let mut expected_html = String::new();
        expected_html_reader
            .read_to_string(&mut expected_html)
            .unwrap();

        assert_eq!(book.content, expected_html);
    }
}
